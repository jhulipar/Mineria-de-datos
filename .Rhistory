knn_cls_spec <-
nearest_neighbor(neighbors = 11, weight_func = "triangular") %>%
# This model can be used for classification or regression, so set mode
set_mode("classification") %>%
set_engine("kknn")
knn_cls_spec
knn_cls_fit <- knn_cls_spec %>% fit(Class ~ ., data = data_train)
knn_cls_fit
bind_cols(
predict(knn_cls_fit, data_test),
predict(knn_cls_fit, data_test, type = "prob")
)
? tidymodels_prefer
View(Chicago)
# modelo prediccion
# cargamos la data
data(Chicago)
View(Chicago)
? Chicago
# seleccionamos variables relevantes
Chicago <- Chicago %>% select(ridership, Clark_Lake, Quincy_Wells)
Chicago_train <- Chicago[1:(n - 7), ]
n
1:(n - 7)
(n - 6):n
# cargo la data
data(two_class_dat)
? two_class_dat
View(two_class_dat)
gc()
pacman::p_load(dbscan, tidyverse, Rtsne, factoextra)
#Aca lee el archivo y lo convierte en un objeto
#Selecionar las columnas que mejor representan la cancion y evitar los datos no númericos
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds") %>%
select("danceability","energy","key","loudness","mode","speechiness","acousticness","instrumentalness","liveness","valence","tempo")%>%
unique()
set.seed(42)
beats_sample<-beats[sample(1:nrow(beats),size=nrow(beats)/10),]
tsne_beats_sample <- Rtsne(beats_sample)%>%
.$Y %>%
as.data.frame()
fviz_nbclust(tsne_beats_sample, kmeans, method = "silhouette")
ggplot(tsne_beats_sample, aes(V1, V2)) + geom_point()
gc?
?gc
?gc
rm(beats_sample,tsne_beats_sample)
tsne_beats <- Rtsne(beats)%>%
.$Y %>%
as.data.frame()
ggplot(tsne_beats_sample, aes(V1, V2)) + geom_point()
ggplot(tsne_beats, aes(V1, V2)) + geom_point()
source("~/GitHub/Mineria-de-datos/Proyecto_1.R")
gc()
pacman::p_load(dbscan, tidyverse, Rtsne, factoextra)
#Aca lee el archivo y lo convierte en un objeto
#Selecionar las columnas que mejor representan la cancion y evitar los datos no númericos
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds") %>%
select(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,liveness,valence,tempo,time_signature,duration_ms)%>%
unique()
set.seed(40)
beats_sample<-beats[sample(1:nrow(beats),size=nrow(beats)/10),]%>%
scale()%>%
as.data.frame()
tsne_beats_sample <- Rtsne(beats_sample,num_threads=0)%>%
.$Y %>%
as.data.frame()
#Graficar los datos
ggplot(tsne_beats_sample, aes(V1, V2)) + geom_point()
#Mostrar como varia la silueta en funcion del nr de clusters
#fviz_nbclust(tsne_beats_sample, kmeans, method = "silhouette")
#Ejecutar el metodo de k-means para el k nr de centroides
cl<-kmeans(tsne_beats_sample,4)
View(cl)
data1 <- rbind(beats_sample, cl$cluster)
View(data1)
cl$cluster
data1 <- rbind(beats_sample, cl$cluster)
View(data1)
clusters<-cl$cluster
data1 <- rbind(beats_sample, t(cl$cluster))
clusters<-t(cl$cluster)
View(clusters)
clusters<-t(cl$cluster)
clusters<-cl$cluster
data1 <- add_row(beats_sample,cl$cluster)
data1 <- cbind(beats_sample, cl$cluster)
View(data1)
rm(clusters)
tsne_beats <- Rtsne(beats,num_threads=0)%>%
.$Y %>%
as.data.frame()
#Graficar los datos
#ggplot(tsne_beats, aes(V1, V2)) + geom_point()
#Mostrar como varia la silueta en funcion del nr de clusters
fviz_nbclust(tsne_beats, kmeans, method = "silhouette")
#Graficar los datos
#ggplot(tsne_beats, aes(V1, V2)) + geom_point()
#No se puede usar el metodo de encontrar los nr de clusters porque son muchos datos y requiere un espacio exagerado de ram
#fviz_nbclust(tsne_beats, kmeans, method = "silhouette")
#Ejecutar el metodo de k-means para el k nr de centroides
cl<-kmeans(tsne_beats,4)
plot(tsne_beats_sample, col = cl$cluster)
points(cl$centers, col = 1:4, pch = 8)
#Graficar los datos
#ggplot(tsne_beats, aes(V1, V2)) + geom_point()
#No se puede usar el metodo de encontrar los nr de clusters porque son muchos datos y requiere un espacio exagerado de ram
#fviz_nbclust(tsne_beats, kmeans, method = "silhouette")
#Ejecutar el metodo de k-means para el k nr de centroides
cl<-kmeans(tsne_beats,4)
#Graficar los datos
#ggplot(tsne_beats, aes(V1, V2)) + geom_point()
#No se puede usar el metodo de encontrar los nr de clusters porque son muchos datos y requiere un espacio exagerado de ram
#fviz_nbclust(tsne_beats, kmeans, method = "silhouette")
#Ejecutar el metodo de k-means para el k nr de centroides
cl<-kmeans(tsne_beats,4)
View(cl)
plot(tsne_beats, col = cl$cluster)
points(cl$centers, col = 1:4, pch = 8)
###
plot(tsne_beats, col = cl$cluster)
points(cl$centers, col = 1:4, pch = 8)
data_with_cluster <- cbind(readRDS("~/GitHub/Mineria-de-datos/beats.rds") %>%
unique()
, cl$cluster)
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds") %>%
unique()
data1 <- cbind(beats
, cl$cluster)
load("~/GitHub/Mineria-de-datos/.RData")
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")
gc()
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds") %>%
select(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,liveness,valence,tempo,time_signature,duration_ms)%>%
unique()
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds") %>%
unique()
?Rtsne
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds") %>%
select(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,liveness,valence,tempo,time_signature,duration_ms)
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds") %>%
select(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,liveness,valence,tempo,time_signature,duration_ms)
set.seed(40)
beats_sample<-beats[sample(1:nrow(beats),size=nrow(beats)/10),]%>%
scale()%>%
as.data.frame()
tsne_beats_sample <- Rtsne(beats_sample,num_threads=0,check_duplicates=F)%>%
.$Y %>%
as.data.frame()
#Mostrar como varia la silueta en funcion del nr de clusters
fviz_nbclust(tsne_beats_sample, kmeans, method = "silhouette")
beats_sample<-beats[sample(1:nrow(beats),size=nrow(beats)/12),]%>%
scale()%>%
as.data.frame()
tsne_beats_sample <- Rtsne(beats_sample,num_threads=0,check_duplicates=F)%>%
.$Y %>%
as.data.frame()
#Mostrar como varia la silueta en funcion del nr de clusters
fviz_nbclust(tsne_beats_sample, kmeans, method = "silhouette")
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")
tsne_beats <- Rtsne(beats,num_threads=0)%>%
.$Y %>%
as.data.frame()
tsne_beats <- Rtsne(beats,num_threads=0)%>%
.$Y %>%
as.data.frame()
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")%>%
select(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,liveness,valence,tempo,time_signature,duration_ms)
tsne_beats <- Rtsne(beats,num_threads=0)%>%
.$Y %>%
as.data.frame()
tsne_beats <- Rtsne(beats,num_threads=0,check_duplicates=F)%>%
.$Y %>%
as.data.frame()
#Ejecutar el metodo de k-means para el k nr de centroides
cl<-kmeans(tsne_beats,4)
plot(tsne_beats, col = cl$cluster)
points(cl$centers, col = 1:4, pch = 8)
gc()
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")
View(beats)
View(beats)
song_id=input("ingresar track id:")
song_id=readline("ingresar track id:")
match(song_id,beats$track_id)
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")%>%
select(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,liveness,valence,tempo,time_signature,duration_ms)
tsne_beats <- Rtsne(beats,num_threads=0,check_duplicates=F)%>%
.$Y %>%
as.data.frame()
#Graficar los datos
#ggplot(tsne_beats, aes(V1, V2)) + geom_point()
#No se puede usar el metodo de encontrar los nr de clusters porque son muchos datos y requiere un espacio exagerado de ram
#Ejecutar el metodo de k-means para el k nr de centroides
cl<-kmeans(tsne_beats,4)
#Visualizar los datos y sus clusters
plot(tsne_beats, col = cl$cluster)
points(cl$centers, col = 1:4, pch = 8)
pacman::p_load(dbscan, tidyverse, Rtsne, factoextra,dplyr)
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")%>%
select(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,liveness,valence,tempo,time_signature,duration_ms)
tsne_beats <- Rtsne(beats,num_threads=0,check_duplicates=F)%>%
.$Y %>%
as.data.frame()
#Graficar los datos
#ggplot(tsne_beats, aes(V1, V2)) + geom_point()
#No se puede usar el metodo de encontrar los nr de clusters porque son muchos datos y requiere un espacio exagerado de ram
#Ejecutar el metodo de k-means para el k nr de centroides
cl<-kmeans(tsne_beats,4)
#Visualizar los datos y sus clusters
plot(tsne_beats, col = cl$cluster)
points(cl$centers, col = 1:4, pch = 8)
data1 <- cbind(beats, cl$cluster)
View(data1)
#Asignar los clusters a la matriz original de canciones
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")
data1 <- cbind(beats, cl$cluster)
View(data1)
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")%>%
select(danceability,energy,key,loudness,mode,speechiness,acousticness,instrumentalness,liveness,valence,tempo,time_signature,duration_ms)
View(beats)
#Asignar los clusters a la matriz original de canciones
beats <- readRDS("~/GitHub/Mineria-de-datos/beats.rds")
View(data1)
?boxplot
?bclust
?bclust
pacman::p_load(dbscan, tidyverse, Rtsne, factoextra,dplyr,ggplot2,e1071)
?bclust
bclust(beats_sample,centers=4,base.method = "kmeans")%>%
bloxplot()
?bloxplot
pacman::p_load(dbscan, tidyverse, Rtsne, factoextra,dplyr,ggplot2,e1071)
?boxplot
bclust(beats_sample,centers=4,base.method = "kmeans")%>%
bloxplot()
?boxplot
bclust(beats_sample,centers=4,base.method = "kmeans")%>%
boxplot()
View(data1)
song_id=readline("ingresar track id:")
#con el match encontrar el cluster al que pertence
cluster_song=beats[match(song_id,beats$track_id),"cl$cluster"]
song_match=match(song_id,beats$track_id)
#con el match encontrar el cluster al que pertence
cluster_song=beats[song_match,"cl$cluster"]
song_match=match(song_id,beats$track_id)
song_match=match(song_id,beats$track_id)
song_match=which(beats$track_id %in% song_id)
song_match=which(beats$track_id %in% song_id)
View(data1)
song_id=readline("ingresar track id:")
song_match=which(beats$track_id %in% song_id)
song_match=which(data1$track_id %in% song_id)
song_match=charmatch(song_id,data1$track_id)
song_id=readline("ingresar track id:")
song_match=charmatch(song_id,data1$track_id)
#con el match encontrar el cluster al que pertence
cluster_song=beats[song_match,"cl$cluster"]
song_match=which(grepl(song_id, data1$track_id))
song_id=readline("ingresar track id:")
song_match=which(grepl(song_id, data1$track_id))
song_match=which(grepl(song_id, data1$track_id))
which(grepl(song_id, data1$track_id))
#con el match encontrar el cluster al que pertence
cluster_song=beats[which(grepl(song_id, data1$track_id)),"cl$cluster"]
song_match=which(grepl(song_id, data1$track_id))
song_match=which(grepl(song_id, data1$track_id))
song_id=readline("ingresar track id:")
song_match=which(grepl(song_id, data1$track_id))
#con el match encontrar el cluster al que pertence
cluster_song=beats[song_match,"cl$cluster"]
#con el match encontrar el cluster al que pertence
cluster_song=beats["cl$cluster",song_match]
10+song_match
#con el match encontrar el cluster al que pertence
cluster_song=beats[song_match[0],"cl$cluster"]
#con el match encontrar el cluster al que pertence
cluster_song=beats[song_match[1],"cl$cluster"]
song_match[0]+10
song_match[1]+10
song_match+10
song_match=match(song_id, data1$track_id)#which(grepl(song_id, data1$track_id))
song_match[1]+10
song_match+10
#con el match encontrar el cluster al que pertence
cluster_song=beats[song_match[1],"cl$cluster"]
#con el match encontrar el cluster al que pertence
cluster_song=beats[song_match,"cl$cluster"]
#con el match encontrar el cluster al que pertence
cluster_song=beats[240836,"cl$cluster"]
#con el match encontrar el cluster al que pertence
cluster_song=data1[240836,"cl$cluster"]
#con el match encontrar el cluster al que pertence
cluster_song=data1[song_match,"cl$cluster"]
song_match=match(song_id, data1$track_id)
#con el match encontrar el cluster al que pertence
cluster_song=data1[song_match,"cl$cluster"]
#con el match encontrar el cluster al que pertence
cluster_song=data1[match(song_id, data1$track_id),"cl$cluster"]
#Una vez con el cluster, crear una lista para obtener todas las canciones que pertencen a ese cluster
song_list <- data.frame(matrix(ncol = 37, nrow = 0))
colnames(song_list) <- colnames(data1)
View(song_list)
?while
?sample
?sample
list_song_cluster=which(song_cluster, data1$`cl$cluster`)
#con el match encontrar el cluster al que pertence
song_cluster=data1[match(song_id, data1$track_id),"cl$cluster"]
list_song_cluster=which(song_cluster, data1$`cl$cluster`)
list_song_cluster=which(song_cluster %in% data1$`cl$cluster`)
list_song_cluster=which(data1$`cl$cluster` %in% song_cluster)
#Agregar la cancion a la lista
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000)#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:nrow(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.NULL(row.match(song_selected,song_list)))#comprobación de que no se repitan canciones
song_selected=data1[list_cluster[sample(1:nrow(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
song_list <-rbind(song_list, song_selected)
while (sum(song_list$duration_ms)<10800000)#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:len(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(row.match(song_selected,song_list)))#comprobación de que no se repitan canciones
song_selected=data1[list_cluster[sample(1:len(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
song_list <-rbind(song_list, song_selected)
while (sum(song_list$duration_ms)<10800000)#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:len(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(row.match(song_selected,song_list)))#comprobación de que no se repitan canciones
song_selected=data1[list_cluster[sample(1:len(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
song_list <-rbind(song_list, song_selected)
pacman::p_load(dbscan, tidyverse, Rtsne, factoextra,dplyr,ggplot2,e1071,prodlim)
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000)#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:lenght(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(row.match(song_selected,song_list)))#comprobación de que no se repitan canciones
song_selected=data1[list_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
song_list <-rbind(song_list, song_selected)
while (sum(song_list$duration_ms)<10800000)#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(row.match(song_selected,song_list)))#comprobación de que no se repitan canciones
song_selected=data1[list_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
song_list <-rbind(song_list, song_selected)
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
song_selected=data1[list_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
View(song_list)
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print("AIUDAAAAA")
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected$track_name)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.null(match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected$track_name)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
match(song_selected,song_list)
row.match(song_selected,song_list)
is.na(row.match(song_selected,song_list))
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.na(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected$track_name)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
View(song_list)
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.na(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected$track_name)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
View(song_list)
song_list <- data.frame(matrix(ncol = 37, nrow = 0))
colnames(song_list) <- colnames(data1)
list_song_cluster=which(data1$`cl$cluster` %in% song_cluster)
#Agregar la cancion a la lista
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.na(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected$track_name)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
View(song_list)
View(data1)
song_id=readline("ingresar track id:")
song_cluster=data1[match(song_id, data1$track_id),"cl$cluster"]
#Una vez con el cluster, crear una lista para obtener todas las canciones que pertencen a ese cluster
song_list <- data.frame(matrix(ncol = 37, nrow = 0))
colnames(song_list) <- colnames(data1)
list_song_cluster=which(data1$`cl$cluster` %in% song_cluster)
#Agregar la cancion a la lista
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.na(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected$track_name)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
song_id=readline("ingresar track id:")
song_cluster=data1[match(song_id, data1$track_id),"cl$cluster"]
#Una vez con el cluster, crear una lista para obtener todas las canciones que pertencen a ese cluster
song_list <- data.frame(matrix(ncol = 37, nrow = 0))
colnames(song_list) <- colnames(data1)
list_song_cluster=which(data1$`cl$cluster` %in% song_cluster)
#Agregar la cancion a la lista
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.na(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected$track_name)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
View(song_list)
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.na(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected$track_name)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
View(song_list)
song_list <- data.frame(matrix(ncol = 37, nrow = 0))
colnames(song_list) <- colnames(data1)
list_song_cluster=which(data1$`cl$cluster` %in% song_cluster)
#Agregar la cancion a la lista
set.seed(NULL)#Para esta parte se requiere desestablecer la semilla, sino lo que pasará es que la cancion que selecioné será siempre la misma
while (sum(song_list$duration_ms)<10800000){#Condición para que llegue a las 3 horas de duración
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()
while (!is.na(row.match(song_selected,song_list))){#comprobación de que no se repitan canciones
print(song_selected$track_name)
song_selected=data1[list_song_cluster[sample(1:length(list_song_cluster),size=1)],]%>% #Selecciona la cancion a partir de tomar una muestra de 1 aleatoria
as.data.frame()}
song_list <-rbind(song_list, song_selected)
}
View(song_list)
